const AWS = require("aws-sdk")
	, _ = require("lodash");

const FromAddress = process.env.FROM_ADDRESS;
const ToAddresses = _.compact(_.map(
	_.split(process.env.EMAIL_LIST, ",")
	, a => _.trim(a)));

//TODO: use CloudWatch Image API to turn graphs into attachments
//@see https://aws.amazon.com/blogs/devops/reduce-time-to-resolution-with-amazon-cloudwatch-snapshot-graphs-and-alerts/

/**
 * Send as email if environment is configured.
 *
 * @param {{}} slackMessage Parsed Slack message
 * @param {{}} event Raw event
 * @returns {Promise} Always-resolving Promise
 */
exports.checkAndSend = async (slackMessage, event) => {
	if (!ToAddresses.length) {
		return null;
	}
	if (!FromAddress) {
		console.error("EMAIL_LIST defined, but FROM_ADDRESS is empty!");
		return null;
	}
	try {
		const body = render(slackMessage, event);
		const subject = subjectFromSlack(slackMessage);
		return await send(subject, body, ToAddresses, FromAddress);
	}
	catch (err) {
		console.log("SES failed:", err);
		return false;
	}
};

/**
 * Send a Slack message as a formatted email.
 *
 * @param {string} subject Email subject
 * @param {{}} body Email body
 * @param {string[]} toEmails Emails to deliver to
 * @param {string} fromEmail Email in the From: header
 * @returns {Promise} Always-resolving Promise
 */
function send(subject, body, toEmails, fromEmail) {
	const params = {
		Source: fromEmail,
		Destination: { ToAddresses: toEmails },
		Message: {
			Body: body,
			Subject: {
				Charset: "UTF-8",
				Data: subject,
			}
		}
	};

	return new AWS.SES({ httpOptions: { timeout: 5000 } })
		.sendEmail(params)
		.promise();
}

function subjectFromSlack(slackMessage) {
	const att = slackMessage.attachments[0];
	let subject = att.title || "Notification";
	if (att.author_name) {
		let author = _.trim(att.author_name);
		if (/^AWS /i.test(author)) {
			author = author.substr(4);
		}
		const r = / \(.*\)$/.exec(author);
		if (r) {
			author = author.substr(0, author.length - r[0].length);
		}
		subject = `[${author}] ${subject}`;
	}
	return subject;
}

/**
 * Render Slack message into HTML email.
 *
 * @param {{}} slackMessage Message generated by parser
 * @param {{}} [event] Raw event from Lambda
 * @returns {{Html: {Charset: string, Data: string}, Text: {Charset: string, Data: string}}} SES-compatible body object
 */
function render(slackMessage, event) {
	const att = slackMessage.attachments[0]
		, html = []
		, text = [];

	const color_map = {
		danger: "#FF324D",
		warning: "#FFD602",
		good:  "#8CC800",
	};
	const color = color_map[att.color] || att.color || "grey";

	html.push(`<!DOCTYPE html>
<html><head></head>
<body style="font-family:sans-serif;">
<div style="padding:4px 4px 4px 1em;border-left:4px solid ${color}">`);

	if (att.author_name) {
		const authLink = !att.author_link ? "" : `href="${escape(att.author_link)}"`;
		html.push(`<a style="display:block;font-size:1.6em;margin:.1em 0;font-weight:bold" ${authLink}>${escape(att.author_name)}</a>`);
		text.push(authLink ? `${att.author_name}\n${att.author_link}\n` : att.author_name);
	}
	if (att.title) {
		const titleLink = !att.title_link ? "" : `href="${escape(att.title_link)}"`;
		html.push(`<a style="display:block;font-size:1.3em;color:#999;" ${titleLink}>${escape(att.title)}</a>`);
		text.push(titleLink ? `${att.title}\n${att.title_link}\n` : att.title);
	}
	if (att.text) {
		html.push(`<p style="margin:1em 0;">${escape(att.text)}</p>`);
		text.push(`\n${att.text}\n`);
	}
	if (att.fields && att.fields.length) {
		html.push("<div style=\"overflow:hidden;\">");
		_.each(att.fields, field => {
			html.push(`<div style="float:left;width:48%"><div style="font-weight:bold">${escape(field.title)}`);
			html.push(`</div><p style="margin:.5em 0">${escape(field.value)}</p></div>`);
			text.push(`> ${field.title}: ${field.value}\n`);
		});
		html.push("</div>");
	}
	if (att.image_url) {
		html.push(`<div><img src="${att.image_url}" alt="Message image"/></div>`);
		text.push(`Image: ${att.image_url}`);
	}

	html.push("</div>");
	html.push("<div style=\"border-top:1px solid #eceef9;color:#999;padding:.5em 0 0;margin:1em 1.5em;font-size:.8em\">");

	// Env vars populated by AWS Lambda runtime
	const lambdaName = process.env.AWS_LAMBDA_FUNCTION_NAME;
	const region = process.env.AWS_REGION;
	if (lambdaName) {
		html.push(`<p style="margin:.5em 0">Generated by <a href="https://console.aws.amazon.com/lambda/home?region=${region}#/functions/${lambdaName}">Lambda ${lambdaName} in ${region}</a></p>`);
		text.push(`\n\nGenerated by Lambda ${lambdaName} in ${region}\n`);
	}

	// Include raw event for debugging later
	if (event) {
		html.push("<p style=\"margin:.5em 0\">This message was generated from the following raw event:</p>");
		html.push(`<pre style="color:#ccc;color:rgba(0,0,0,.08);font-size:.5em;font-weight:100;line-height:.8;letter-spacing:-1px;word-break:break-all;white-space:pre-wrap;">${escape(JSON.stringify(event))}</pre>`);
	}
	html.push("</div>");

	html.push("</body></html>");

	return {
		Html: {
			Charset: "UTF-8",
			Data: html.join("\n"),
		},
		Text: {
			Charset: "UTF-8",
			Data: text.join("\n"),
		}
	};
}

/**
 * Escape HTML string.
 *
 * @param {string} str Raw string
 * @returns {string} Escaped string
 */
function escape(str) {
	// Links
	str = _.replace(str, /<([^|]+)\|([^>]+)>/g, (s, a1, a2) => `<a href="${a1}">${escape(a2)}</a>`);
	// HTML-escape characters
	str = _.replace(str, /["'&<>]/g, s => {
		switch (s.charCodeAt(0)) {
		case 34: // "
			return "&quot;";
		case 38: // &
			return "&amp;";
		case 39: // '
			return "&#39;";
		case 60: // <
			return "&lt;";
		case 62: // >
			return "&gt;";
		default:
			return s;
		}
	});
	// Add <b> tags for * text
	str = _.replace(str, /(^|[^*])\*([^*]*)\*([^*]|$)/g, (s, a1, a2, a3) => `${a1}<b>${a2}</b>${a3}`);
	return str;
}
